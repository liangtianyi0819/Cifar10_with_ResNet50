# -*- coding: utf-8 -*-
"""CS767Assignment9_Question1&2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fSTi7OTkt5NZ3QMIg2IyvYxIm2Ax_cUu
"""

import os
import numpy as np
import tensorflow as tf

from tensorflow import keras
from tensorflow.keras import layers
from tensorflow.keras.datasets import cifar10
from tensorflow.keras.preprocessing import image
from tensorflow.keras.models import Model, load_model
from tensorflow.keras.layers import Dense, Activation, Input, Add, BatchNormalization, Flatten, Conv2D, \
    AveragePooling2D, MaxPooling2D, ZeroPadding2D


def set_seed():
    InitSeed = 767
    tf.random.set_seed(InitSeed)
    np.random.seed(InitSeed)


def one_hot(Y, C):
    Y = np.eye(C)[Y.reshape(-1)].T
    return Y


tf.config.run_functions_eagerly(True)
(x_train_full, y_train_full), (x_test, y_test) = cifar10.load_data()
x_train, x_valid = x_train_full[:-5000] / 255, x_train_full[-5000:] / 255
y_train, y_valid = y_train_full[:-5000], y_train_full[-5000:]
x_train = x_train[..., np.newaxis]
x_valid = x_valid[..., np.newaxis]
x_test = x_test[..., np.newaxis]

y_train = one_hot(y_train, 10).T
y_valid = one_hot(y_valid, 10).T
y_test = one_hot(y_test, 10).T
print("X_train shape: " + str(x_train.shape) +
      "\nY_train shape: " + str(y_train.shape) +
      "\nX_test shape: " + str(x_test.shape) +
      "\nY_test shape: " + str(y_test.shape) +
      "\nX_valid shape: " + str(x_valid.shape) +
      "\nY_valid shape: " + str(y_valid.shape))


#
def block(X, filters, first_block=False):
    """
  X: input
  filters: List, dim of filters in [f1, f2, f3]
  first_block: Bool, if this block is the first block of this big "layer"

  return: the output X went through all layers in this block
  """
    # Receive filter dimension information
    f1, f2, f3 = filters
    output_cut = X

    # By using functional API
    # First layer
    if first_block:
        output_ = Conv2D(filters=f1, kernel_size=(1, 1), strides=(2, 2), padding='valid')(X)
    else:
        output_ = Conv2D(filters=f1, kernel_size=(1, 1), strides=(1, 1), padding='valid')(X)
    output_ = BatchNormalization(axis=3)(output_)
    output_ = Activation('relu')(output_)

    # Second layer
    output_ = Conv2D(filters=f2, kernel_size=(3, 3), strides=(1, 1), padding='same')(output_)
    output_ = BatchNormalization(axis=3)(output_)
    output_ = Activation('relu')(output_)

    # Third layer
    output_ = Conv2D(filters=f3, kernel_size=(1, 1), strides=(1, 1), padding='valid')(output_)
    output_ = BatchNormalization(axis=3)(output_)

    if first_block:
        output_cut = Conv2D(filters=f3, kernel_size=(1, 1), strides=(2, 2), padding='valid')(output_cut)
        output_cut = BatchNormalization(axis=3)(output_cut)

    output_ = Add()([output_, output_cut])
    output_ = Activation('relu')(output_)

    return output_


# Start creating the network
# Since cifar10 is 32x32x3, 10 classes output,
def resNet50(dim=(224, 224, 3), label=10):
    # Receive input
    X = Input(dim)
    output_ = ZeroPadding2D((3, 3))(X)

    # ================ 7x7, 64, stride 2 ================
    output_ = Conv2D(64, (7, 7), strides=(2, 2))(output_)
    output_ = BatchNormalization(axis=3)(output_)
    output_ = Activation('relu')(output_)

    # ============= 3x3 max pool, stride 2 =============
    output_ = MaxPooling2D((3, 3), strides=(2, 2))(output_)

    # ======================= Blocks =======================
    """
  |1 x 1, 64.|
  |3 x 3, 64.| X 3
  |1 x 1, 256|"""
    output_ = block(output_, filters=[64, 64, 256], first_block=True)
    output_ = block(output_, filters=[64, 64, 256], first_block=False)
    output_ = block(output_, filters=[64, 64, 256], first_block=False)

    """
  |1 x 1, 128|
  |3 x 3, 128| X 4
  |1 x 1, 512|
  """
    output_ = block(output_, filters=[128, 128, 512], first_block=True)
    for i in range(3):
        output_ = block(output_, filters=[128, 128, 512], first_block=False)

    """
  |1 x 1, 256.|
  |3 x 3, 256.| X 6
  |1 x 1, 1024|
  """
    output_ = block(output_, filters=[256, 256, 1024], first_block=True)
    for i in range(5):
        output_ = block(output_, filters=[256, 256, 1024], first_block=False)

    """
  |1 x 1, 512.|
  |3 x 3, 512.| X 3
  |1 x 1, 2048|
  """
    output_ = block(output_, filters=[512, 512, 2048], first_block=True)
    output_ = block(output_, filters=[512, 512, 2048], first_block=False)
    output_ = block(output_, filters=[512, 512, 2048], first_block=False)

    # average pooling, softmax
    output_ = AveragePooling2D((2, 2), padding='same')(output_)
    output_ = Flatten()(output_)
    output_ = Dense(label, activation='softmax', )(output_)

    # Aggregate as a model
    model = Model(inputs=X, outputs=output_)
    return model


set_seed()
model = resNet50(dim=(224, 224, 3), label=10)
model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

model.fit(x_train, y_train, validation_data=(x_valid, y_valid), epochs=5)
